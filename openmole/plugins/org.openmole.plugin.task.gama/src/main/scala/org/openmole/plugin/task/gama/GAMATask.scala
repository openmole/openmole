package org.openmole.plugin.task.gama

import org.openmole.core.dsl.*
import org.openmole.core.dsl.extension.*
import org.openmole.core.setter.*
import org.openmole.core.workspace.{TmpDirectory, Workspace}
import org.openmole.plugin.task.container
import org.openmole.plugin.task.container.*
import org.openmole.plugin.task.external.*

import scala.xml.XML

object GAMATask:
  def workspaceDirectory = "/_workspace_"
  def inputXML = s"/_model_input_.xml"
  def gamaWorkspaceDirectory = s"$workspaceDirectory/_gama_workspace_"

  def volumes(
    workspace: File,
    model:     String) =
    val content = workspace.listFiles.map { f => f -> s"$gamaWorkspaceDirectory/${f.getName}"}.toSeq
    (model, content)

  def prepare(
    workspace:              File,
    model:                  String,
    experiment:             String,
    install:                Seq[String],
    containerSystem:        Option[ContainerSystem],
    image:                  ContainerImage,
    clearCache:             Boolean)(implicit tmpDirectory: TmpDirectory, serializerService: SerializerService, outputRedirection: OutputRedirection, networkService: NetworkService, threadProvider: ThreadProvider, preference: Preference, _workspace: Workspace, fileService: FileService) =

    val installedImage =
      ContainerTask.install(
        containerSystem,
        image,
        install,
        Seq(),
        clearCache = clearCache)

    val (modelName, volumesValue) = volumes(workspace, model)

    def outputDirectoryPath = s"$gamaWorkspaceDirectory/_output_"

    def gamaCommand = s"gama-headless -xml '$experiment' '$gamaWorkspaceDirectory/$modelName' '$outputDirectoryPath/$inputXML'"
    def inputFileCommands = Seq(gamaCommand)

    val inputXMLString =
      TmpDirectory.withTmpDir: outputDirectory =>
        val ret =
          ContainerTask.runCommandInContainer(
            installedImage,
            volumes = volumesValue.map((lv, cv) ⇒ lv.getAbsolutePath -> cv) ++ Seq(outputDirectory.getAbsolutePath -> outputDirectoryPath),
            commands = inputFileCommands,
            output = outputRedirection.output,
            error = outputRedirection.error
          )

        ret match
          case 1 => throw InternalProcessingError(s"There was an error in GAMA headless while crating the experiment file, you may try to reproduce it using GAMA headless. The command looks like: $gamaCommand")
          //case 2 => Some(s"""the file $inputXML has not been generated by "gama-headless -xml"""")
          case _ =>


        (outputDirectory / inputXML).content

    try XML.loadString(inputXMLString)
    catch
      case t: Throwable => throw InternalProcessingError(s"Can't parse XML:\n$inputXMLString", t)

    (installedImage, inputXMLString)


  def modifyInputXML(values: Map[String, String], finalStep: Int, seed: Long, frameRate: Option[Int]) =
    import xml._
    import xml.transform._

    def value(n: Node): Option[String] =
      if (n.label != "Parameter") None
      else n.attribute("var").flatMap(_.headOption.map(_.text)).flatMap(values.get) orElse n.attribute("name").flatMap(_.headOption.map(_.text)).flatMap(values.get)

    val rewrite =
      new RewriteRule:
        override def transform(n: Node): Seq[Node] =
          (n, value(n), frameRate) match
            case (n: Elem, Some(v), _) ⇒ n.copy(attributes = n.attributes.remove("value").append(Attribute(null, "value", v, Null)))
            case (n: Elem, _, _) if n.label == "Simulation" =>
              n.copy(attributes =
                n.attributes
                  .remove("finalStep").append(Attribute(null, "finalStep", finalStep.toString, Null))
                  .remove("seed").append(Attribute(null, "seed", seed.toDouble.toString, Null))
              )
            case (n: Elem, _, Some(f)) if n.label == "Output" =>
              n.copy(attributes = n.attributes.remove("framerate").append(Attribute(null, "framerate", f.toString, Null)))
            case _ ⇒ n

    new RuleTransformer(rewrite)


  def acceptedOutputType(frame: Boolean): Seq[Manifest[?]] =
    def scalar =
      Seq(
        manifest[Double],
        manifest[Int],
        manifest[String],
        manifest[Boolean]
      )

    if !frame
    then scalar
    else scalar.map(_.arrayManifest)


  def checkXML(inputXMLString: String, experiment: String, frameRate: Option[Int], mapped: MappedInputOutputConfig) =
    import xml.*

    val parsedInputXML = XML.loadString(inputXMLString)

    val parameters = (parsedInputXML \ "Simulation" \ "Parameters" \ "Parameter").collect { case x: Elem => x }
    val outputs = (parsedInputXML \ "Simulation" \ "Outputs" \ "Output").collect { case x: Elem => x }

    def gamaParameters = parameters.flatMap(e => e.attribute("var").flatMap(_.headOption).map(_.text)) ++ parameters.flatMap(e => e.attribute("name").flatMap(_.headOption).map(_.text))

    def gamaParameterByName(name: String) =
      parameters.find(e => e.attribute("var").flatMap(_.headOption).map(_.text).contains(name) || e.attribute("name").flatMap(_.headOption).map(_.text).contains(name))

    def gamaOutputs = outputs.flatMap(e => e.attribute("name").flatMap(_.headOption).map(_.text))

    def gamaOutputByName(name: String) =
      outputs.find(e => e.attribute("name").flatMap(_.headOption).map(_.text).contains(name))


    def validateInputs =
      def typeMatch(v: Val[?], t: String) =
        v match
          case Val.caseInt(v) => t == "INT" | t == "FLOAT"
          case Val.caseDouble(v) => t == "INT" | t == "FLOAT"
          case Val.caseString(v) => t == "STRING"
          case Val.caseBoolean(v) => t == "BOOLEAN"
          case _ => false

      Mapped.noFile(mapped.inputs).flatMap: m =>
        gamaParameterByName(m.name) match
          case Some(p) =>
            val gamaType = p.attribute("type").get.head.text
            if (!typeMatch(m.v, gamaType)) Some(new UserBadDataError(s"""Type mismatch between mapped input ${m.v} and input "${m.name}" of type ${gamaType}.""")) else None
          case None => Some(new UserBadDataError(s"""Mapped input "${m.name}" has not been found in the simulation among: ${gamaParameters.mkString(", ")}. Make sure it is defined in your gaml file"""))

    def validateOutputs =
      val acceptedOutputsTypes = GAMATask.acceptedOutputType(frameRate.isDefined)

      def accepted(c: Manifest[?]) = acceptedOutputsTypes.exists(t => t == c)

      Mapped.noFile(mapped.outputs).flatMap: m =>
        gamaOutputByName(m.name) match
          case Some(_) => if (!accepted(m.v.`type`.manifest)) Some(new UserBadDataError(s"""Mapped output ${m} type is not supported (frameRate is ${frameRate.isDefined}, it implies that supported types are: ${acceptedOutputsTypes.mkString(", ")})""")) else None
          case None => Some(new UserBadDataError(s"""Mapped output "${m.name}" has not been found in the simulation among: ${gamaOutputs.mkString(", ")}. Make sure it is defined in your gaml file."""))

    if (parsedInputXML \ "Simulation").isEmpty
    then Seq(new UserBadDataError(s"Experiment ${experiment} has not been found, make sure it is defined in your gaml file"))
    else validateInputs ++ validateOutputs

  def apply(
    project:                File,
    gaml:                   String,
    experiment:             String,
    finalStep:              FromContext[Int],
    seed:                   OptionalArgument[Val[Long]]         = None,
    frameRate:              OptionalArgument[Int]               = None,
    temporaryVolumes:       Seq[String]                         = Seq.empty,
    install:                Seq[String]                         = Seq.empty,
    containerImage:         ContainerImage                      = "gamaplatform/gama:1.9.2",
    memory:                 OptionalArgument[Information]       = None,
    version:                OptionalArgument[String]            = None,
    errorOnReturnValue:     Boolean                             = true,
    returnValue:            OptionalArgument[Val[Int]]          = None,
    stdOut:                 OptionalArgument[Val[String]]       = None,
    stdErr:                 OptionalArgument[Val[String]]       = None,
    environmentVariables:   Seq[EnvironmentVariable]            = Vector.empty,
    hostFiles:              Seq[HostFile]                       = Vector.empty,
    //    workDirectory:          OptionalArgument[String]       = None,
    clearContainerCache:    Boolean                             = false,
    containerSystem:        OptionalArgument[ContainerSystem]   = None)(using sourcecode.Name, DefinitionScope) =

    ExternalTask.build("GAMATask"): buildParameters =>
      import buildParameters.*

      if !project.exists() then throw new UserBadDataError(s"The project directory you specify does not exist: ${project}")
      if !(project / gaml).exists() then throw new UserBadDataError(s"The model file you specify does not exist: ${project / gaml}")

      val gamaContainerImage: ContainerImage =
        (version.option, containerImage) match
          case (None, c) => c
          case (Some(v), c: DockerImage) => c.copy(tag = v)
          case (Some(_), _: SavedDockerImage) => throw new UserBadDataError(s"Can not set both, a saved docker image, and, set the version of the container.")

      val (preparedImage, inputXML) =
        import taskExecutionBuildContext.given
        prepare(project, gaml, experiment, install, containerSystem, gamaContainerImage, clearCache = clearContainerCache)

      checkXML(inputXML, experiment, frameRate.option, mapped) match
        case errors if errors.nonEmpty => throw MultipleException(errors)
        case _ =>

      val inputFilePath = s"${GAMATask.workspaceDirectory}/_inputs_openmole_.xml"

      def outputDirectoryPath = s"${GAMATask.workspaceDirectory}/_output_"

      def launchCommand =
        memory.option match
          case None => s"gama-headless -hpc 1 $inputFilePath $outputDirectoryPath"
          case Some(m) => s"gama-headless -m ${m.toMegabytes.toLong}m -hpc 1 $inputFilePath $outputDirectoryPath"

      val containerTaskExecution =
        ContainerTask.execution(
          image = preparedImage,
          command = launchCommand,
          workDirectory = Some(GAMATask.workspaceDirectory),
          relativePathRoot = Some(GAMATask.gamaWorkspaceDirectory),
          errorOnReturnValue = errorOnReturnValue,
          returnValue = returnValue,
          hostFiles = hostFiles,
          environmentVariables = environmentVariables,
          stdOut = stdOut,
          stdErr = stdErr,
          config = config,
          external = external,
          info = info)

      ExternalTask.execution: executionParameters =>
        import executionParameters.*

        val inputFile = executionContext.taskExecutionDirectory.newFile("input", ".xml")
        val outputDirectory = executionContext.taskExecutionDirectory.newDirectory("output", create = true)

        val seedValue = math.abs(seed.map(_.from(context)).getOrElse(random().nextLong))

        def inputMap = Mapped.noFile(mapped.inputs).map { m ⇒ m.name -> context(m.v).toString }.toMap

        val parsedInputXML =
          val parsedInputXML = XML.loadString(inputXML)
          GAMATask.modifyInputXML(inputMap, finalStep.from(context), seedValue, frameRate.option).transform(parsedInputXML)

        inputFile.content =
          s"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>${parsedInputXML.mkString("")}"""

        val (_, volumes) = GAMATask.volumes(project, gaml)
        val temporaryVolumeMapping =
          temporaryVolumes.map: d =>
            val emptyDirectory = executionContext.taskExecutionDirectory.newDirectory("result", create = true)
            emptyDirectory-> s"$gamaWorkspaceDirectory/$d"

        def containerTask =
          containerTaskExecution.set(
            resources += (inputFile, inputFilePath, true),
            resources += (outputDirectory, outputDirectoryPath, true),
            (temporaryVolumeMapping ++ volumes).map((lv, cv) => resources += (lv, cv, true)),
            Mapped.files(mapped.inputs).map { m ⇒ inputFiles += (m.v, m.name, true) },
            Mapped.files(mapped.outputs).map { m ⇒ outputFiles += (m.name, m.v) }
          )

        val resultContext = containerTask(executionContext).from(context)

        def gamaOutputFile =
          outputDirectory.
            listFilesSafe.
            filter(f => f.isFile && f.getName.startsWith("simulation-outputs") && f.getName.endsWith(".xml")).
            sortBy(_.getName).headOption.getOrElse(throw new InternalProcessingError(s"""GAMA result file (simulation-outputsXX.xml) has not been found, the content of the output folder is: [${outputDirectory.list.mkString(", ")}]"""))

        try
          (Mapped.noFile(mapped.outputs).isEmpty, frameRate.option) match
            case (true, _) => resultContext
            case (false, None) =>
              import xml._

              def toVariable(v: Val[?], value: String) =
                v match
                  case Val.caseInt(v) => Variable(v, value.toInt)
                  case Val.caseDouble(v) => Variable(v, value.toDouble)
                  case Val.caseString(v) => Variable(v, value)
                  case Val.caseBoolean(v) => Variable(v, value.toBoolean)
                  case _ => throw new UserBadDataError(s"Unsupported type of output variable $v (supported types are Int, Double, String, Boolean)")

              val outputs = Map[String, Val[?]]() ++ Mapped.noFile(mapped.outputs).map { m => (m.name, m.v) }

              def outputValue(e: Elem) =
                for
                  a <- e.attribute("name").flatMap(_.headOption)
                  value <- outputs.get(a.text)
                yield toVariable(value, e.child.text)

              def extractOutputs(n: Node) =
                (n \ "Variable").flatMap:
                  case e: Elem => outputValue(e)
                  case _ => None

              val simulationOutput = XML.loadFile(gamaOutputFile) \ "Step"

              resultContext ++ extractOutputs(simulationOutput.last)
            case (false, Some(f)) =>
              import xml._

              def toVariable(v: Val[?], value: Array[String]) =
                v match
                  case Val.caseArrayInt(v) => Variable(v, value.map(_.toInt))
                  case Val.caseArrayDouble(v) => Variable(v, value.map(_.toDouble))
                  case Val.caseArrayString(v) => Variable(v, value)
                  case Val.caseArrayBoolean(v) => Variable(v, value.map(_.toBoolean))
                  case _ => throw new UserBadDataError(s"Unsupported type of output variable $v (supported types are Array[Int], Array[Double], Array[String], Array[Boolean])")

              def outputValue(e: Elem, name: String) =
                for
                  a <- e.attribute("name").flatMap(_.headOption)
                  if a.text == name
                  if e.child.text != "NA"
                yield e.child.text

              val simulationOutput = XML.loadFile(gamaOutputFile) \ "Step"

              resultContext ++
                Mapped.noFile(mapped.outputs).map: m =>
                  val values =
                    for
                      o <- simulationOutput
                      v <- o \ "Variable"
                    yield
                      v match
                        case o: Elem => outputValue(o, m.name)
                        case _ => None
                  toVariable(m.v, values.flatten.toArray)

        catch
          case t: Throwable =>
            def parseOutputError(t: Throwable) =
              InternalProcessingError(
                s"""Error parsing the result file, it might be caused by an error during the execution of GAMA, you should look at the standard output.
                   |Result file content was: ${gamaOutputFile.content}
                   |Experiment file content was: ${inputFile.content}
                   |GAMA was launched using the command: $launchCommand
                   |""".stripMargin, t)

            throw parseOutputError(t)
    .withValidate: info =>
      ContainerTask.validateContainer(Vector(), environmentVariables, info.external) ++ finalStep.validate
    .set(
      inputs ++= seed.option.toSeq,
      outputs ++= Seq(returnValue.option, stdOut.option, stdErr.option).flatten
    )





