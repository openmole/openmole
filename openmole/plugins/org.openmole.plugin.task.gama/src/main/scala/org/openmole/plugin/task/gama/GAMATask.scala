package org.openmole.plugin.task.gama

import java.io.FileNotFoundException

import monocle.Focus
import org.openmole.core.dsl.*
import org.openmole.core.dsl.extension.*
import org.openmole.core.exception.{InternalProcessingError, UserBadDataError}
import org.openmole.core.fileservice.FileService
import org.openmole.core.networkservice.NetworkService
import org.openmole.core.preference.Preference
import org.openmole.core.serializer.SerializerService
import org.openmole.core.threadprovider.ThreadProvider
import org.openmole.core.setter._
import org.openmole.core.workflow.task._
import org.openmole.core.workflow.validation._
import org.openmole.core.workspace.{TmpDirectory, Workspace}
import org.openmole.plugin.task.container
import org.openmole.plugin.task.container._
import org.openmole.plugin.task.external._
import org.openmole.tool.outputredirection.OutputRedirection

import scala.xml.XML

object GAMATask:

  given InputOutputBuilder[GAMATask] = InputOutputBuilder(Focus[GAMATask](_.config))
  given ExternalBuilder[GAMATask] = ExternalBuilder(Focus[GAMATask](_.external))
  given InfoBuilder[GAMATask] = InfoBuilder(Focus[GAMATask](_.info))
  given MappedInputOutputBuilder[GAMATask] = MappedInputOutputBuilder(Focus[GAMATask](_.mapped))

  def workspaceDirectory = "/_workspace_"
  def inputXML = s"/_model_input_.xml"
  def gamaWorkspaceDirectory = s"$workspaceDirectory/_gama_workspace_"

  def volumes(
    workspace: File,
    model:     String) =
    val content = workspace.listFiles.map { f => f -> s"$gamaWorkspaceDirectory/${f.getName}"}.toSeq
    (model, content)

  def prepare(
    workspace:              File,
    model:                  String,
    experiment:             String,
    install:                Seq[String],
    installContainerSystem: ContainerSystem,
    image:                  ContainerImage,
    clearCache:             Boolean)(implicit tmpDirectory: TmpDirectory, serializerService: SerializerService, outputRedirection: OutputRedirection, networkService: NetworkService, threadProvider: ThreadProvider, preference: Preference, _workspace: Workspace, fileService: FileService) =

    val (modelName, volumesValue) = volumes(workspace, model)

    def gamaCommand = s"gama-headless -xml '$experiment' '$gamaWorkspaceDirectory/$modelName' '$inputXML'"
    def installCommands = install ++ Seq(gamaCommand, s"ls '${inputXML}'")

    def error(retCode: Int) =
      retCode match
        case 1 => Some(s"There was an error in GAMA headless while crating the experiment file, you may try to reproduce it using GAMA headless. The command looks like: $gamaCommand")
        case 2 => Some(s"""the file $inputXML has not been generated by "gama-headless -xml"""")
        case _ => None

    ContainerTask.install(
      installContainerSystem,
      image,
      installCommands,
      volumesValue.map { (lv, cv) ⇒ lv -> cv },
      error,
      clearCache = clearCache)

  def apply(
    project:                File,
    gaml:                   String,
    experiment:             String,
    finalStep:              FromContext[Int],
    seed:                   OptionalArgument[Val[Long]]      = None,
    frameRate:              OptionalArgument[Int]            = None,
    install:                Seq[String]                      = Seq.empty,
    containerImage:         ContainerImage                   = "gamaplatform/gama:1.9.2",
    memory:                 OptionalArgument[Information]    = None,
    version:                OptionalArgument[String]         = None,
    errorOnReturnValue:     Boolean                          = true,
    returnValue:            OptionalArgument[Val[Int]]       = None,
    stdOut:                 OptionalArgument[Val[String]]    = None,
    stdErr:                 OptionalArgument[Val[String]]    = None,
    environmentVariables:   Seq[EnvironmentVariable]         = Vector.empty,
    hostFiles:              Seq[HostFile]                    = Vector.empty,
    //    workDirectory:          OptionalArgument[String]       = None,
    clearContainerCache:    Boolean                          = false,
    containerSystem:        ContainerSystem                  = ContainerSystem.default,
    installContainerSystem: ContainerSystem                  = ContainerSystem.default,
    overlay:                OverlayConfiguration             = OverlayConfiguration.default)(implicit name: sourcecode.Name, definitionScope: DefinitionScope, newFile: TmpDirectory, _workspace: Workspace, preference: Preference, fileService: FileService, threadProvider: ThreadProvider, outputRedirection: OutputRedirection, networkService: NetworkService, serializerService: SerializerService): GAMATask =

    if !project.exists() then throw new UserBadDataError(s"The project directory you specify does not exist: ${project}")
    if !(project / gaml).exists() then throw new UserBadDataError(s"The model file you specify does not exist: ${project / gaml}")

    val gamaContainerImage: ContainerImage =
      (version.option, containerImage) match
        case (None, c) => c
        case (Some(v), c: DockerImage) => c.copy(tag = v)
        case (Some(_), _: SavedDockerImage) => throw new UserBadDataError(s"Can not set both, a saved docker image, and, set the version of the container.")

    val preparedImage = prepare(project, gaml, experiment, install, installContainerSystem, gamaContainerImage, clearCache = clearContainerCache)

    GAMATask(
      project = project,
      gaml = gaml,
      experiment = experiment,
      finalStep = finalStep,
      seed = seed,
      frameRate = frameRate,
      image = preparedImage,
      memory = memory,
      errorOnReturnValue = errorOnReturnValue,
      returnValue = returnValue,
      stdOut = stdOut,
      stdErr = stdErr,
      hostFiles = hostFiles,
      environmentVariables = environmentVariables,
      containerSystem = containerSystem,
      config = InputOutputConfig(),
      external = External(),
      info = InfoConfig(),
      mapped = MappedInputOutputConfig(),
      overlay = overlay
    ) set (
        inputs ++= seed.option.toSeq,
        outputs ++= Seq(returnValue.option, stdOut.option, stdErr.option).flatten
      )


  def modifyInputXML(values: Map[String, String], finalStep: Int, seed: Long, frameRate: Option[Int]) =
    import xml._
    import xml.transform._

    def value(n: Node): Option[String] =
      if (n.label != "Parameter") None
      else n.attribute("var").flatMap(_.headOption.map(_.text)).flatMap(values.get) orElse n.attribute("name").flatMap(_.headOption.map(_.text)).flatMap(values.get)

    val rewrite =
      new RewriteRule:
        override def transform(n: Node): Seq[Node] =
          (n, value(n), frameRate) match
            case (n: Elem, Some(v), _) ⇒ n.copy(attributes = n.attributes.remove("value").append(Attribute(null, "value", v, Null)))
            case (n: Elem, _, _) if n.label == "Simulation" =>
              n.copy(attributes =
                n.attributes
                  .remove("finalStep").append(Attribute(null, "finalStep", finalStep.toString, Null))
                  .remove("seed").append(Attribute(null, "seed", seed.toDouble.toString, Null))
              )
            case (n: Elem, _, Some(f)) if n.label == "Output" =>
              n.copy(attributes = n.attributes.remove("framerate").append(Attribute(null, "framerate", f.toString, Null)))
            case _                  ⇒ n

    new RuleTransformer(rewrite)


  def acceptedOutputType(frame: Boolean): Seq[Manifest[_]] =
    def scalar =
      Seq(
        manifest[Double],
        manifest[Int],
        manifest[String],
        manifest[Boolean]
      )

    if !frame
    then scalar
    else scalar.map(_.arrayManifest)


case class GAMATask(
  project:              File,
  gaml:                 String,
  experiment:           String,
  finalStep:            FromContext[Int],
  seed:                 OptionalArgument[Val[Long]],
  frameRate:            OptionalArgument[Int],
  image:                InstalledImage,
  memory:               OptionalArgument[Information],
  errorOnReturnValue:   Boolean,
  returnValue:          Option[Val[Int]],
  stdOut:               Option[Val[String]],
  stdErr:               Option[Val[String]],
  hostFiles:            Seq[HostFile],
  environmentVariables: Seq[EnvironmentVariable],
  containerSystem:      ContainerSystem,
  config:               InputOutputConfig,
  external:             External,
  info:                 InfoConfig,
  mapped:               MappedInputOutputConfig,
  overlay:              OverlayConfiguration) extends Task with ValidateTask:

  def readInputXML(image: InstalledImage)(using tmpDirectory: TmpDirectory, outputRedirection: OutputRedirection) =
    tmpDirectory.withTmpDir: dir =>
      val bindDirectory = s"/__copy__"
      val copyDirectory = dir /> "copy"

      _root_.container.Singularity.executeImage(
        image,
        dir / "tmp",
        commands = Seq(s"cp -rf ${GAMATask.inputXML} $bindDirectory"),
        bind = Seq(copyDirectory.getAbsolutePath -> bindDirectory),
        output = outputRedirection.output,
        error = outputRedirection.error,
        singularityCommand = containerSystem.command,
        singularityWorkdir = Some(dir /> "singularitytmp")
      )

      XML.loadFile(copyDirectory / GAMATask.inputXML)

  override def validate =
    container.validateContainer(Vector(), environmentVariables, external) ++ finalStep.validate ++
      Validate: p =>
        import p.*
        import xml.*

        val inputXML = readInputXML(image)

        val parameters = (inputXML \ "Simulation" \ "Parameters" \ "Parameter").collect { case x: Elem => x }
        val outputs = (inputXML \ "Simulation" \ "Outputs" \ "Output").collect { case x: Elem => x }

        def gamaParameters = parameters.flatMap(e => e.attribute("var").flatMap(_.headOption).map(_.text)) ++ parameters.flatMap(e => e.attribute("name").flatMap(_.headOption).map(_.text))
        def gamaParameterByName(name: String) =
          parameters.find(e => e.attribute("var").flatMap(_.headOption).map(_.text).contains(name) || e.attribute("name").flatMap(_.headOption).map(_.text).contains(name))

        def gamaOutputs = outputs.flatMap(e => e.attribute("name").flatMap(_.headOption).map(_.text))
        def gamaOutputByName(name: String) =
          outputs.find(e => e.attribute("name").flatMap(_.headOption).map(_.text).contains(name))


        def validateInputs =
          def typeMatch(v: Val[_], t: String) =
            v match
              case Val.caseInt(v) => t == "INT" | t == "FLOAT"
              case Val.caseDouble(v) => t == "INT" | t == "FLOAT"
              case Val.caseString(v) => t == "STRING"
              case Val.caseBoolean(v) => t == "BOOLEAN"
              case _ => false

          Mapped.noFile(mapped.inputs).flatMap: m =>
            gamaParameterByName(m.name) match
              case Some(p) =>
                val gamaType = p.attribute("type").get.head.text
                if(!typeMatch(m.v, gamaType)) Some(new UserBadDataError(s"""Type mismatch between mapped input ${m.v} and input "${m.name}" of type ${gamaType}.""")) else None
              case None => Some(new UserBadDataError(s"""Mapped input "${m.name}" has not been found in the simulation among: ${gamaParameters.mkString(", ")}. Make sure it is defined in your gaml file"""))

        def validateOutputs =
          val acceptedOutputsTypes = GAMATask.acceptedOutputType(frameRate.option.isDefined)
          def accepted(c: Manifest[_]) = acceptedOutputsTypes.exists(t => t == c)

          Mapped.noFile(mapped.outputs).flatMap: m =>
            gamaOutputByName(m.name) match
              case Some(_) => if(!accepted(m.v.`type`.manifest)) Some(new UserBadDataError(s"""Mapped output ${m} type is not supported (frameRate is ${frameRate.option.isDefined}, it implies that supported types are: ${acceptedOutputsTypes.mkString(", ")})""")) else None
              case None => Some(new UserBadDataError(s"""Mapped output "${m.name}" has not been found in the simulation among: ${gamaOutputs.mkString(", ")}. Make sure it is defined in your gaml file."""))

        if (inputXML \ "Simulation").isEmpty
        then Seq(new UserBadDataError(s"Experiment ${experiment} has not been found, make sure it is defined in your gaml file"))
        else validateInputs ++ validateOutputs


  override def process(executionContext: TaskExecutionContext) = FromContext: p ⇒
    import p.*
    import executionContext.outputRedirection

    val inputFilePath = s"${GAMATask.workspaceDirectory}/_inputs_openmole_.xml"
    val inputFile = executionContext.taskExecutionDirectory.newFile("input", ".xml")

    def outputDirectoryPath = s"${GAMATask.workspaceDirectory}/_output_"
    val outputDirectory = executionContext.taskExecutionDirectory.newDirectory("output", create = true)

    val seedValue = math.abs(seed.map(_.from(context)).getOrElse(random().nextLong))

    def inputMap = Mapped.noFile(mapped.inputs).map { m ⇒ m.name -> context(m.v).toString }.toMap

    val inputXML =
      val inputXML = readInputXML(image)
      GAMATask.modifyInputXML(inputMap, finalStep.from(context), seedValue, frameRate.option).transform(inputXML)

    inputFile.content =
      s"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>${inputXML.mkString("")}"""

    val (_, volumes) = GAMATask.volumes(project, gaml)

    def launchCommand =
      memory.option match
        case None => s"gama-headless -hpc 1 $inputFilePath $outputDirectoryPath"
        case Some(m) => s"gama-headless -m ${m.toMegabytes.toLong}m -hpc 1 $inputFilePath $outputDirectoryPath"

    def containerTask =
      ContainerTask.internal(
        image = image,
        command = launchCommand,
        containerSystem = containerSystem,
        workDirectory = Some(GAMATask.workspaceDirectory),
        relativePathRoot = Some(GAMATask.gamaWorkspaceDirectory),
        errorOnReturnValue = errorOnReturnValue,
        returnValue = returnValue,
        hostFiles = hostFiles,
        environmentVariables = environmentVariables,
        stdOut = stdOut,
        stdErr = stdErr,
        config = config,
        external = external,
        info = info,
        overlay = overlay) set(
        resources += (inputFile, inputFilePath, true),
        resources += (outputDirectory, outputDirectoryPath, true),
        volumes.map { (lv, cv) ⇒ resources += (lv, cv, true) },
        Mapped.files(mapped.inputs).map { m ⇒ inputFiles += (m.v, m.name, true) },
        Mapped.files(mapped.outputs).map { m ⇒ outputFiles += (m.name, m.v) }
      )

    val resultContext = containerTask.process(executionContext).from(context)

    def gamaOutputFile =
      outputDirectory.
        listFilesSafe.
        filter(f => f.isFile && f.getName.startsWith("simulation-outputs") && f.getName.endsWith(".xml")).
        sortBy(_.getName).headOption.getOrElse(throw new InternalProcessingError(s"""GAMA result file (simulation-outputsXX.xml) has not been found, the content of the output folder is: [${outputDirectory.list.mkString(", ")}]"""))

    try
      (Mapped.noFile(mapped.outputs).isEmpty, frameRate.option) match
        case (true, _) => resultContext
        case (false, None) =>
          import xml._

          def toVariable(v: Val[_], value: String) =
            v match
              case Val.caseInt(v) => Variable(v, value.toInt)
              case Val.caseDouble(v) => Variable(v, value.toDouble)
              case Val.caseString(v) => Variable(v, value)
              case Val.caseBoolean(v) => Variable(v, value.toBoolean)
              case _ => throw new UserBadDataError(s"Unsupported type of output variable $v (supported types are Int, Double, String, Boolean)")

          val outputs = Map[String, Val[_]]() ++ Mapped.noFile(mapped.outputs).map { m => (m.name, m.v) }
          def outputValue(e: Elem) =
            for
              a <- e.attribute("name").flatMap(_.headOption)
              value <- outputs.get(a.text)
            yield toVariable(value, e.child.text)

          def extractOutputs(n: Node) =
            (n \ "Variable").flatMap:
              case e: Elem => outputValue(e)
              case _ => None

          val simulationOutput = XML.loadFile(gamaOutputFile) \ "Step"

          resultContext ++ extractOutputs(simulationOutput.last)
        case (false, Some(f)) =>
          import xml._

          def toVariable(v: Val[_], value: Array[String]) =
            v match
              case Val.caseArrayInt(v) => Variable(v, value.map(_.toInt))
              case Val.caseArrayDouble(v) => Variable(v, value.map(_.toDouble))
              case Val.caseArrayString(v) => Variable(v, value)
              case Val.caseArrayBoolean(v) => Variable(v, value.map(_.toBoolean))
              case _ => throw new UserBadDataError(s"Unsupported type of output variable $v (supported types are Array[Int], Array[Double], Array[String], Array[Boolean])")

          def outputValue(e: Elem, name: String) =
            for
              a <- e.attribute("name").flatMap(_.headOption)
              if a.text == name
            yield e.child.text

          val simulationOutput = XML.loadFile(gamaOutputFile) \ "Step"

          resultContext ++
            Mapped.noFile(mapped.outputs).map: m =>
              val values =
                for
                  o <- simulationOutput
                  v <- o \ "Variable"
                yield
                  v match
                    case o: Elem => outputValue(o, m.name)
                    case _ => None
              toVariable(m.v, values.flatten.toArray)

    catch
      case t: Throwable =>
        def parseOutputError(t: Throwable) =
          InternalProcessingError(
            s"""Error parsing the result file, it might be caused by an error during the execution of GAMA, you should look at the standard output.
               |Result file content was: ${gamaOutputFile.content}
               |Experiment file content was: ${inputFile.content}
               |GAMA was launched using the command: $launchCommand
               |""".stripMargin, t)
        throw parseOutputError(t)




