package org.openmole.site.content.explore.sampling

/*
 * Copyright (C) 2023 Romain Reuillon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import org.openmole.site.content.header.*

object Aggregation extends PageContent(html"""


${h2{"Aggregating Results of a Direct Sampling"}}

${h3{"In Arrays"}}

Direct sampling and offers a way to aggregate the multiple output value of the model generated by the multiple execution of the model. This is done by settings the argument aggregation of the ${code{"Direct Sampling"}} or ${code{"Replication"}} method.

The simplest usage is to generate an array of all the computed outputs. You can then store it using a hook or pass it to a subsequent task:


${hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   val postProcessingTask =
     ScalaTask($tq
       // my post processing code
     $tq) set (
       inputs += (output1.array, output2.array)
     )

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(output1, output2)
   ) -- postProcessingTask
""", header = "val my_own_model = EmptyTask()", name = "aggregate array")}

${h3{"Statistic Indicators"}}

OpenMOLE provides a bunch on statistic function you can use to aggregate you outputs. The list of these function is ${a("available in the doc", href := DocumentationPages.scalaFunction.file)}.

You can use these function either in a ${code{"ScalaTask"}} to post process your results or using the ${code("evaluate")} keyword:
${hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate median,
       output2 evaluate average
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "aggregate statistics")}

${h3{"You own function"}}

You can also provide your own scala function to aggregate the data, as it is shown in the following example:

${hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate "output1.sum / 3.0",
       output2 evaluate "output2.sum / 3.0"
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "my aggregate text function")}

Or:

${hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   def myAggregation(d: Array[Double]) = d.sum / 3.0

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate myAggregation,
       output2 evaluate myAggregation
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "my aggregate function")}


""")
