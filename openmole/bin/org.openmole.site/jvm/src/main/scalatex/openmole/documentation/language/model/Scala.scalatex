@import org.openmole.site.tools._
@import org.openmole.site._


@p
  You can program tasks in Scala using the @hl.openmole("ScalaTask"). For instance the following workflow sums all the elements of an array using a @hl.openmole("ScalaTask") and displays the results. Similarly, you could use such a task to generate some model parameter values or perform some data analysis. To get more details on the hook part you can check the doc on @aa("hooks", href := DocumentationPages.hook.file).

  @hl.openmole("""
  val array = Val[Array[Double]]
  val result = Val[Double]

  val sum = ScalaTask("val result = array.sum") set (
      inputs += array,
      outputs += result,
      array := Array(8.0, 9.0, 10.0)
    )

  (sum hook ToStringHook())""")

  You can embed you own Scala/Java code and libraries in OpenMOLE using an OpenMOLE @a("Plugin", href := DocumentationPages.plugin.file).

@p In addition to scala code, OpenMOLEÂ provides @a("a few useful function to aggregate data, create files, create random number generators", href := DocumentationPages.scalaFunction.file).

@p
  Multiple @i{ScalaTasks} can be joined to compose a workflow. Lets imagine that you want to perform an expensive computation on every element of an array. For the sake of simplicity, the "expensive computation" is here a multiplication by 2.

  @hl.openmole("""
  val element = Val[Double]
  val multiplied = Val[Double]
  val result = Val[Double]

  val expensive = ScalaTask("val multiplied = element * 2") set (
    inputs += element,
    outputs += multiplied
  )

  val exploration = ExplorationTask(element in List(8.0, 9.0, 10.0))

  val sum = ScalaTask("val result = multiplied.sum") set (
    inputs += multiplied.toArray,
    outputs += result
  )

  exploration -< expensive >- (sum hook ToStringHook())""")

@p
  The execution of this workflow can be distributed using OpenMOLE's environments. Check the page dedicated to @a("environments", href := DocumentationPages.environment.file) to learn more on this process.



