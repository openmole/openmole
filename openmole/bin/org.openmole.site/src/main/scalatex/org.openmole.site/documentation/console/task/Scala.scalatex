@import org.openmole.site.Objects._
@import org.openmole.site.DocumentationPages

@sect{Simple Scala task}
  You can program your data processing tasks using the @hl.openmole("ScalaTask"). For instance the following
  workflow sums all the elements of an array using a @hl.openmole("ScalaTask") and displays the results. To get more
  details on the hook part you can check the doc on @a("hooks", href := DocumentationPages.root.console.hook.file).

  @br @hl.openmole("""
    val array = Val[Array[Double]]
    val result = Val[Double]

    val sum = ScalaTask("val result = array.sum") set (
        inputs += array,
        outputs += result,
        array := Array(8.0, 9.0, 10.0)
      )

    val ex = (sum hook ToStringHook()) start""")


  @p Multiple @i{ScalaTasks} can be joint to compose a workflow. Lets imagine that you want to
  perform an expensive computation on every element of an array. For the sake of simplicity, the "expensive computation"
  is here a multiplication by 2.

  @br @hl.openmole("""
    val element = Val[Double]
    val multiplied = Val[Double]
    val result = Val[Double]

    val expensive = ScalaTask("val multiplied = element * 2") set (
      inputs += element,
      outputs += multiplied
    )

    val exploration = ExplorationTask(element in List(8.0, 9.0, 10.0))

    val sum = ScalaTask("val result = multiplied.sum") set (
      inputs += multiplied.toArray,
      outputs += result
    )

    val ex = exploration -< expensive >- (sum hook ToStringHook()) start""")

  @p The execution of this workflow can be distributed using OpenMOLE's environments. Check the page dedicated to
  @a("environments", href := DocumentationPages.root.console.environment.file) to learn more on this process.

@sect{Execute your Java code into OpenMOLE}

  OpenMOLE makes it simple to include your own Java code in a workflow. A Java program can be encapsulated in a task of
  a workflow. The task should be a ScalaTask and the Java program should be packaged as a JAR archive passed to the
  ScalaTask through the @hl.openmoleNoTest("libraries") parameter.

  @sect{Hello world}
      Let us consider the simple code @em{Hello.java} in a directory named @i{hello} (to respect Java's package
      structure):
      @hl.highlight("""
      package hello;

      public class Hello {
        public static void run(int arg) {
          System.out.println("Hello from Java! " + arg);
        }
      }""", "java")
      @p We compile the code and generate the JAR file as follows:
      @hl.highlight("""
      mkdir hello
      mv Hello.java hello
      cd hello
      javac Hello.java
      cd ..
      jar cvf Hello.jar hello""", "plain")

      @p Here is how the Java program is embedded into a ScalaTask, the following being OpenMOLE code:
      @hl.openmole("""
      val proto1 = Val[Int]

      val explo = ExplorationTask(proto1 in (0 until 10))

      //Defines the task to perform the hello function
      val javaTask = ScalaTask("Hello.run(proto1)") set (
        libraries += "/path/to/Hello.jar",
        imports += "hello._",
        inputs += proto1
      )

      val ex = explo -< javaTask start""")

      @p The output should look like that (the order in which the lines are printed might be different in your case):
      @hl.highlight("""
      Hello from Java! 0
      Hello from Java! 1
      Hello from Java! 2
      Hello from Java! 3
      Hello from Java! 4
      Hello from Java! 5
      Hello from Java! 6
      Hello from Java! 7
      Hello from Java! 8
      Hello from Java! 9
      Hello from Java! 10""", "plain")

  @sect{Computing}
    @p In the general case a task is used to compute some output values depending on some input values. To illustrate
    that, let's consider another Java code:
    @hl.highlight("""
    package hello;

    public class Hello {
      public static double[] run(double arg1, double arg2) {
        return double[]{arg1 * 10, arg2 * 10};
      }
    }""", "java")

    @p Once you have packaged this code in the same way as before, it can be explored in OpenMOLE:

      @hl.openmole("""
      val arg1 = Val[Double]
      val arg2 = Val[Double]
      val out1 = Val[Double]
      val out2 = Val[Double]

      val explo = ExplorationTask(
        (arg1 in (0.0 to 10.0 by 1.0)) x
        (arg2 in (0.0 until 10.0 by 1.0))
      )

      val javaTask = ScalaTask("Array(out1, out2) = Hello.run(arg1, arg2)") set (
        libraries += "/path/to/Hello.jar",
        imports += "hello._",
        inputs += (arg1, arg2),
        outputs += (arg1, arg2, out1, out2)
      )

      // save the result in a CSV file
      val csvHook = AppendToCSVFileHook("/tmp/result.csv")

      val ex = explo -< (javaTask hook csvHook) start""")

    @p This workflow explores the 2 arguments of the @i{hello} function and saves the results in a CSV file.

  @sect{Working with files}
      @p Let's consider another "hello world" code Hello.java. This program reads the content of a file and writes it to
      another file.
      @hl.highlight("""
      package hello;

      import java.io.*;

      public class Hello {

        public static void run(int arg, File input, File output) throws IOException {
          //Read the input file
          String content = readFileAsString(input);
          PrintStream myStream = new PrintStream(new FileOutputStream(output));
          try {
            myStream.println(content + "  " + arg);
          } finally {
            myStream.close();
          }
        }

        private static String readFileAsString(File file) throws IOException {
          byte[] buffer = new byte[(int) file.length()];
          BufferedInputStream f = null;
          try {
            f = new BufferedInputStream(new FileInputStream(filePath));
            f.read(buffer);
          } finally {
            if (f != null) try { f.close(); } catch (IOException ignored) { }
          }
          return new String(buffer);
        }
      }""", "java")

      @p This Java program can be run inside the OpenMOLE runtime with the following script:

      @hl.openmole("""
      val proto1 = Val[Int]
      val inputFile = Val[File]
      val outputFile = Val[File]

      val explo = ExplorationTask(proto1 in (0 to 10))

      //Defines the scala task as a launcher of the hello executable
      val javaTask =
        ScalaTask("val outputFile = newFile(); Hello.run(proto1, inputFile, outputFile)") set (
          libraries += "/path/to/my/Hello.jar",
          imports += "hello.Hello",
          inputs += proto1,
          outputs += proto1,
          inputFile := "/path/to/my/input/file"
        )

      //Save the output file locally
      val copyHook =
        CopyFileHook(
          outputFile,
          "/path/to/save/the/output/file/out-${proto1}.txt"
        )

      val ex = explo -< (javaTask hook copyHook) start""")

      @p This tutorial works for simple Java programs. For more ambitious developments, you should consider embedding
      your code in an ("OpenMOLE plugin", href=DocumentationPages.root.development.plugin.file).
